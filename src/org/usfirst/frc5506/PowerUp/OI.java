// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5506.PowerUp;

import org.usfirst.frc5506.PowerUp.commands.*;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.buttons.Button;
import edu.wpi.first.wpilibj.buttons.JoystickButton;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * This class is the glue that binds the controls on the physical operator
 * interface to the commands and command groups that allow control of the robot.
 */
public class OI {
    //// CREATING BUTTONS
    // One type of button is a joystick button which is any button on a joystick.
    // You create one by telling it which joystick it's on and which button
    // number it is.
    // Joystick stick = new Joystick(port);
    // Button button = new JoystickButton(stick, buttonNumber);

    // There are a few additional built in buttons you can use. Additionally,
    // by subclassing Button you can create custom triggers and bind those to
    // commands the same as any other Button.

    //// TRIGGERING COMMANDS WITH BUTTONS
    // Once you have a button, it's trivial to bind it to a button in one of
    // three ways:

    // Start the command when the button is pressed and let it run the command
    // until it is finished as determined by it's isFinished method.
    // button.whenPressed(new ExampleCommand());

    // Run the command while the button is being held down and interrupt it once
    // the button is released.
    // button.whileHeld(new ExampleCommand());

    // Start the command when the button is released  and let it run the command
    // until it is finished as determined by it's isFinished method.
    // button.whenReleased(new ExampleCommand());

    public Joystick joystick;

    public OI() {
        joystick = new Joystick(0);

        // SmartDashboard Buttons
        //SmartDashboard.putData("Calibrate Arm", new CalibrateArm());//TODO: uncomment when armPos exists
        
        //These help for debugging purposes -- is bad code in the command, or the OI?
        SmartDashboard.putData("Extend", new MoveArm(true));
        SmartDashboard.putData("Retract", new MoveArm(false));
        SmartDashboard.putData("Grip", new MoveHand(true));
        SmartDashboard.putData("Ungrip", new MoveHand(false));
        
        //make button objects -- bind a joystick's input to a code object
        Button openHand = new JoystickButton(joystick, 3); //B
        Button closeHand = new JoystickButton(joystick, 1); //A
        Button retractArm = new JoystickButton(joystick, 2); //X
        Button extendArm = new JoystickButton(joystick, 4); //Y I have no ideas if thes are really right button names but whatef
      
        openHand.whenPressed(new MoveHand(false));
        
        closeHand.whenPressed(new MoveHand(true));
        
        retractArm.whenPressed(new MoveArm(false));//not extending, is moving
        //retractArm.whenReleased(new MoveArm(false, false));//not extending, not moving
        //retractArm.whenReleased(new StopArm());
        
        extendArm.whenPressed(new MoveArm(true));//is extending, is moving
        //extendArm.whenReleased(new MoveArm(true, false));//is extending, not moving
        //extendArm.whenReleased(new StopArm());
        
        /*<button>.whileHeld(Command command) would seem like the right method to use for the
        arm extensions, but it actually constantly calls cancel for the command when it isn't
        pressed, so where we have two buttons, whenever you push one, the other unpushed button
        is constantly cancelling any movement of the other command using end() or interrupted()*/
    }
    
    public Joystick getjoystick() {
        return joystick;
    }
}

