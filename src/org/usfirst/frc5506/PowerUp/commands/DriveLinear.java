
// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5506.PowerUp.commands;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc5506.PowerUp.Robot;

/**
 *
 */
public class DriveLinear extends Command {
	private char mode;
	private double drivePercent;
	private int count;
    private double aveDist;
    private double dist;
    private boolean forward;
    private double percentDone;

    public DriveLinear(double driveDistance, char mode) {
    	dist = driveDistance;
    	this.mode = mode;
    	
        requires(Robot.driveBase);
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    	count = 0;
    	if(mode!='0') 
    		dist /= 100;//if going by time, then divide input by 100 TODO: play with value divisor (dividend?) for timed drive
    	System.out.println(dist);
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
    	if(mode=='0') {//distance mode
    		forward = dist<0 ? false : true;//is dist less than 0? If yes, then forward is false, if no, then forward is true
        	
        	Robot.driveBase.driveLinear(forward);
        	
        	
    	} else if(mode=='2') {//temporary time mode, until acceleration curve is working
    		Robot.driveBase.driveLinear(true);//drive forward
    		
    		
    	} else if(mode=='1') {//timed acceleration curve
    		count++;
			percentDone = count / (50*dist);//get a percentage for how far through the command we are
								  //it's 50*dist, because this will give us how many periods are run in that amount of seconds
								  //we stop when percentDone==1, and this function gets run once every period,
								  //so 50periods/second * length of command in seconds (dist) will give us how many periods are run
								  //before we have reached the time we set, or 100% of the command in periods.
			
			drivePercent = Robot.driveBase.driveCurve(percentDone);
			SmartDashboard.putNumber("Motors running at: ", drivePercent);
			Robot.driveBase.getMotors().arcadeDrive(drivePercent, 0);//run motors at value given by driveCurve, without turning
			
			
    	} else {
    		System.out.println("Invalid mode in DriveLinear");
    	}
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
    	switch(mode) {
    	
    	case '0'://if not  based on time, thus based on distance...
        	aveDist = ( Robot.driveBase.getLeftRotation().getDistance() + Robot.driveBase.getRightRotation().getDistance() ) / 2;//average is more accurate than one wheel
        	return Math.abs(aveDist)>=Math.abs(dist);//if we've travelled as far as we're supposed to, return true
        	
    	case '1':
    		return percentDone>=1;//if we're at 100%, then stop the robot
    		
    	default:
    		return isTimedOut();//if based on time, see if were done
    	}
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {//this is different than  M.D. we want to be stopped so we can run Turn starting from speed = 0
    	Robot.driveBase.stop();//stop the robot duh
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    }
}
